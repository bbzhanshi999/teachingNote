# 第七章 面向对象高级特性

## 1.继承

```java
class Student{
    String name;
    int age;
    void study(){
        sop(name+"。。。student study");
    }
}

class worker{
    String name;
    int age ;	
    void work(){
    	sop(name+"... work")
	}
}

main(){
    Student s =  new Student();
    s.study();
}
```

以上Student 和Worker有重复代码，需要抽取。student 和worker都是人，都有姓名，所以以上所有信息都应该属于人公有的特性。让学生和工人都继承人

```java
class Person{
    String name;
    int age;
}
class Student extends Person{
   // String name;
    //int age;
    void study(){
        sop(name+"。。。student study");
    }
}

class worker extends Person{
   // String name;
    //int age ;	
    void work(){
    	sop(name+"... work")
	}
}

main(){
    Student s =  new Student();
    s.study();
}
```

1. Person 叫父类，基类或超类
2. Student和Worker叫子类

### 1.1 继承的好处

1. 提高了代码复用性。
2. 让类与类之间产生了关系给第三个特征多态提供了前提。

![](images\继承.PNG)

类图：

[uml](https://baike.baidu.com/item/统一建模语言/3160571?fromtitle=UML&fromid=446747&fr=aladdin)中的类图来表示继承：

 ![](images\uml泛化继承.PNG)

### 1.2 java的继承

java的继承是单继承，不支持多继承，对c++进行的多继承进行了改良

#### 单继承：

一个子类只能有一个父类。

#### 多继承：

一个子类可以有多个父类。（java进行了改良）

> java不直接支持多继承，因为多个父类中有多个相同成员，会产生调用的不确定性。（一个儿子只能有一个爹）
>
> 在java中是通过多实现的方式实现了多继承的思想，说白了就是接口

```java
//单继承例子
class A{
    void show(){sop("a")}
}
class B{
    void show(){sop("b")}
}
class C extends B{}
//多继承
class C extends A,B{}
//多继承的问题
new C().show(); //不确定性，不知道继承了A还是B的show

```

#### Java支持多重继承

C继承B，B继承A

![](images\多重继承.PNG)

A定义了这个继承体系里最基本的功能。

总结：

1. 要想使用类似的体系的一个框架、工具集、API，请先去看顶层的接口或者父类的定义
2. 实际使用的时候往往又是使用底层类。

### 1.3 继承的使用

误区：提高复用性就弄继承，是否继承不看复用，看关系

例如：

```java
class Dog{
    void run()
    void eat()
    void yap()
}

class Student{
    void run()
    void eat()
    void study()
}
//都有run，eat方法，按时谁也不该继承谁
//二者有共性的关系，都是animal
class Animal{
    void run()
    void eat()
}
```

#### 1.3.1什么时候用继承

当类与类之间存在所属关系的时候就定义继承。xxx是yyy中的一种，xxx就可以继承yyy

所属关系：is a关系

#### 1.3.2 继承的内存模型

##### 1.3.2.1 子父类中成员的特点体现：

1.成员变量 2.成员函数 3.构造函数

##### 1.3.2.2 成员变量的继承

```java
//成员变量
class Fu{
    int num1 = 4;
}

class Zi extends Fu{
    int num2 =5;
    void show(){
        sop(num2+"...."+num1);
    }
}

class ExtendDemo2{
    main{
        Zi z = new Zi();
        z.show(); //5.....4
    }
}

//--------------------------------------
//特殊情况，父子都有num，简单的说，就是子有就不找父，
//从内存而言，自己的内存空间中由，就不找外面的
class Fu{
    int num = 4;
}

class Zi extends Fu{
    int num =5;
    void show(){
        sop(num+"...."+num);
    }
}

class ExtendDemo2{
    main{
        Zi z = new Zi();
        z.show(); //5.....5
    }
}

//--------------------------------------
// 当本类的成员和局部变量我们用this区分
// 当子父类中变量同名，用super区分父类
//this和super的用法很相似
class Fu{
    int num = 4;
}

class Zi extends Fu{
    int num =5;
    void show(){
        sop(num+"...."+super.num);//super代表父类
    }
}

class ExtendDemo2{
    main{
        Zi z = new Zi();
        z.show(); //5.....4 因为用了super
    }
}

//this代表了一个本类对象的引用，super不代表父类的对象，而是代表一个父类的空间
//代码中从来没有创建过父类对象，子类为什么能获得父类的内容，只是因为子类持有super的引用
```

**结论**

1. this代表了一个本类对象的引用，super不代表父类的对象，而是代表一个父类的空间
2. 代码中从来没有创建过父类对象，子类为什么能获得父类的内容，只是因为子类持有super的引用

**以上结论的内存模型**：

![](images\继承成员变量内存关系.PNG)

> 上图作为了解，现实开发环境中，基本不会出现这种情况
>
> 例如上面的num其实只要在父类里定义就行，并且通常情况下都是私有的，通过set get方法就可以访问，没有必要重新定义。、

思考一个问题：父类中的私有内容，子类持不持有？？

确切的说，子类不能直接访问父类的私有内容，但是可以通过get，set间接访问

##### 1.3.2.3 成员函数的继承

```java
class Fu{
    void show1(){
        sop("fu show run");
    }
}

class Zi extends Fu{
    void show2(){
        sop("zi show run");
    }
}

class ExtendDemo2{
    main{
        Zi z = new Zi();
        z.show1(); 
        z.show2();
    }
}
```

内存示意：![](images\成员函数继承1.PNG)

```java
//子父都叫show方法
class Fu{
    void show(){
        sop("fu show run");
    }
}

class Zi extends Fu{
    void show(){
        sop("zi show run");
    }
}

class ExtendDemo2{
    main{
        Zi z = new Zi();
        z.show(); //zi show run	
    }
}
```

**结论：**

当子父类中出现成员函数一模一样的情况，会运行子类的函数，这种现象较作为覆盖操作，这是子父类中的特性。

函数的两个特性：

1. 重载，在一个类中。
2. 覆盖，在子类中，覆盖也称为重写，覆写，override。

**覆盖的注意事项：**

1. 子类方法覆盖父类方法时，子类权限必须要要大于等于父类的权限。

   ```java
   //错误例子
   class Fu{
       public void show(){
           sop("fu show run");
       }
   }
   
   class Zi extends Fu{
       void show(){ //不能覆盖 ，不信编译试试，编译不通过
           sop("zi show run");
       }
   }
   //--------------------------------------
   //下面这种情况不叫覆盖，覆盖只得是子类能调用的父类方法，private了子类根本访问不了，谈不上覆盖
   class Fu{
       private void show(){
           sop("fu show run");
       }
   }
   
   class Zi extends Fu{
       public void show(){ //不能覆盖 ，不信编译试试，编译不通过
           sop("zi show run");
       }
   }
   ```

2. 静态函数只能覆盖静态函数，或被静态函数覆盖

   ```java
   class Fu{
       private staic void show(){
           sop("fu show run");
       }
   }
   
   class Zi extends Fu{
       public void show(){ //不能覆盖 ，不信编译试试，编译不通过
           sop("zi show run");
       }
   }
   ```

**什么时候使用覆盖操作**

当对一个类进行子类的扩展时，子类需要报错父类的功能声明，但是要定义子类中该功能的特有内容是时，就是用覆盖才做完成。

```java
class Iphone{
    void call(){}
    void certification(){
        // password verify
    }
}
class IphoneX extends Iphone{
    void call(){}
    void certification(){
        // faceId verify
        //最后如果还要调用父类的方法
        super.certification();
    }
}
```

##### 1.3.2.4 构造函数的继承

```java
class Fu{
    Fu(){
        sop("fu run");
    }
}

class Zi{
    Zi(){
        sop("zi run");
    }
}

class ExtendsDemo4{
    main(){
       new Zi(); //1.Fu run  2.zi run 
    }
}
```

构造函数继承特点：

​	在子类构造对象时，发现	访问子类	构造函数时，父类也运行了。

why？

原因是：在子类的构造函数中第一行有一个默认的隐式语句：super();

> 注意，super（）调用的是空参构造函数

```java
class Fu{
    Fu(){
        sop("fu run");
    }
}

class Zi{
    Zi(){
        //super();//类似于this() //代表调用了父类的空参数构造函数
        sop("zi run");
    }
}

class ExtendsDemo4{
    main(){
       new Zi(); //1.Fu run  2.zi run 
    }
}
//--------------------------------------
//以下代码编译错误
class Fu{
    Fu(int x){
        sop("fu run");
    }
}

class Zi{
    Zi(){
        //super();父类没有空参构造函数
        // super(4);这样写没问题
        sop("zi run");
    }
}
```

**结论：**

子类的实例化过程中，子类中**所有的构造函数默认**都会访问父类中**空参数**的**构造函数**。

> 练习：以下代码打印什么？
>
> ![](images\构造继承练习.PNG)

##### 1.3.2.5 为什么子类的实例化的时候要访问父类的构造函数？

因为子类继承了父类，就要能访问父类中的部分成员，然后父类中的成员的初始化动作往往在构造函数中进行，因此，子类在执行自己的构造函数之前，先要执行父类的。

```java
class Fu{
    int num;
    Fu(){
        num = 10;
        sop("fu run");
    }
}

class Zi{
    Zi(){
        
        sop("zi run:"+num);//如果父类不执行构造，这的num=0，而构造了就等于10
    }
}
```

如果父类中没有定义父类的空参构造函数，那么子类的构造函数必须要用super明确调用父类哪个构造函数

同时子类构造函数中使用this调用了本类构造函数时，那么super()就没有了因为super和this都要定义在第一行，所以只能有一个，但是可以保证的是，子类中肯定会有其他额构造函数访问父类的构造函数。

> 注,super（）必须放在第一行，先执行父类构造函数，再执行子类

```java
public class ExtendsDemo {

    public static void main(String[] args) {
        
    }
}
class Fu{
    int num;
    Fu(){
        num = 10;
        System.out.println("fu run:"+num);
    }
    Fu(int num){
        this.num = num;
        System.out.println("fu run:"+num);

    }
}

class Zi extends Fu{
    Zi(){
        
        System.out.println("zi run:"+num);//如果父类不执行构造，这的num=0，而构造了就等于10
    }
    Zi(int num ){
        super(num);
        System.out.println("zi run:"+num);//如果父类不执行构造，这的num=0，而构造了就等于10
    }
}
```

> 构造函数的权限修饰符如果不写，那么就与类的修饰符一致
>
> ```java
> public class Foo // extends Object{
>     Foo(){ //与public Foo相同
>         super(); //即使没有显示继承，也有父类，上帝Object
>         return ;
>     }
> }
> ```

##### 1.3.2.6 对象实例化过程图解

思考：以下代码打印什么？

```java
public class ExtendsDemo5 {

    public static void main(String[] args) {
        Zi zi = new Zi();
        zi.show();
        
        //zi show:0
		//zi show:8
    }
}

class Fu{
    Fu(){
        //super();
        show();
    }
    void show(){
        sop("fu show");
    }
}

class Zi extends Fu{
    int num = 8 ;
    Zi(){
        super();
        //------->这里是分水岭，通过supoer初始化父类内容时，子类的成员变量并未显式初始化
        //等super（）父类完成后，才进行子类显式初始化
        System.out.println("constructor run :"+num);//打印8
        //打印8 因为父类先初始化，只有当父类初始化完毕才轮到子类的显式初始化，因此这时候8已经初始化了
    }
    void show(){
        sop("zi show:"+num);
    }
}
```

内存图解：（重点在构造器部分）

![](images\实例初始化过程.PNG)

一个对象的实例化过程：Person p = new Person();

1. Jvm读取指定路径下的Perosn.class文件，并加载进内存

   并会先加载Person的父类（如有有直接父类的情况下）

2. 在堆内存中开辟空间，分配地址。

3. 对对象中的成员变量进行默认初始化。

4. 调用对应的构造函数开始构造初始化。

5. 在构造函数中，会先调用父类的构造函数进行初始化。

6. 父类初始化完毕后，再对子类的成员变量进行显示初始化。

7. 再进行子类构造函数的特定初始化。

8. 初始化完毕后，将地址值赋给引用变量。（引用变量可不见得一定在栈内）