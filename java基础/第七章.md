# 第七章 面向对象高级特性

## 1.继承

```java
class Student{
    String name;
    int age;
    void study(){
        sop(name+"。。。student study");
    }
}

class worker{
    String name;
    int age ;	
    void work(){
    	sop(name+"... work")
	}
}

main(){
    Student s =  new Student();
    s.study();
}
```

以上Student 和Worker有重复代码，需要抽取。student 和worker都是人，都有姓名，所以以上所有信息都应该属于人公有的特性。让学生和工人都继承人

```java
class Person{
    String name;
    int age;
}
class Student extends Person{
   // String name;
    //int age;
    void study(){
        sop(name+"。。。student study");
    }
}

class worker extends Person{
   // String name;
    //int age ;	
    void work(){
    	sop(name+"... work")
	}
}

main(){
    Student s =  new Student();
    s.study();
}
```

1. Person 叫父类，基类或超类
2. Student和Worker叫子类

### 1.1 继承的好处

1. 提高了代码复用性。
2. 让类与类之间产生了关系给第三个特征多态提供了前提。

![](images\继承.PNG)

类图：

[uml](https://baike.baidu.com/item/统一建模语言/3160571?fromtitle=UML&fromid=446747&fr=aladdin)中的类图来表示继承：

 ![](images\uml泛化继承.PNG)

### 1.2 java的继承

java的继承是单继承，不支持多继承，对c++进行的多继承进行了改良

#### 单继承：

一个子类只能有一个父类。

#### 多继承：

一个子类可以有多个父类。（java进行了改良）

> java不直接支持多继承，因为多个父类中有多个相同成员，会产生调用的不确定性。（一个儿子只能有一个爹）
>
> 在java中是通过多实现的方式实现了多继承的思想，说白了就是接口

```java
//单继承例子
class A{
    void show(){sop("a")}
}
class B{
    void show(){sop("b")}
}
class C extends B{}
//多继承
class C extends A,B{}
//多继承的问题
new C().show(); //不确定性，不知道继承了A还是B的show

```

#### Java支持多重继承

C继承B，B继承A

![](images\多重继承.PNG)

A定义了这个继承体系里最基本的功能。

总结：

1. 要想使用类似的体系的一个框架、工具集、API，请先去看顶层的接口或者父类的定义
2. 实际使用的时候往往又是使用底层类。

### 1.3 继承的使用

误区：提高复用性就弄继承，是否继承不看复用，看关系

例如：

```java
class Dog{
    void run()
    void eat()
    void yap()
}

class Student{
    void run()
    void eat()
    void study()
}
//都有run，eat方法，按时谁也不该继承谁
//二者有共性的关系，都是animal
class Animal{
    void run()
    void eat()
}
```

#### 1.3.1什么时候用继承

当类与类之间存在所属关系的时候就定义继承。xxx是yyy中的一种，xxx就可以继承yyy

所属关系：is a关系

#### 1.3.2 继承的内存模型

##### 1.3.2.1 子父类中成员的特点体现：

1.成员变量 2.成员函数 3.构造函数

##### 1.3.2.2 成员变量的继承

```java
//成员变量
class Fu{
    int num1 = 4;
}

class Zi extends Fu{
    int num2 =5;
    void show(){
        sop(num2+"...."+num1);
    }
}

class ExtendDemo2{
    main{
        Zi z = new Zi();
        z.show(); //5.....4
    }
}

//--------------------------------------
//特殊情况，父子都有num，简单的说，就是子有就不找父，
//从内存而言，自己的内存空间中由，就不找外面的
class Fu{
    int num = 4;
}

class Zi extends Fu{
    int num =5;
    void show(){
        sop(num+"...."+num);
    }
}

class ExtendDemo2{
    main{
        Zi z = new Zi();
        z.show(); //5.....5
    }
}

//--------------------------------------
// 当本类的成员和局部变量我们用this区分
// 当子父类中变量同名，用super区分父类
//this和super的用法很相似
class Fu{
    int num = 4;
}

class Zi extends Fu{
    int num =5;
    void show(){
        sop(num+"...."+super.num);//super代表父类
    }
}

class ExtendDemo2{
    main{
        Zi z = new Zi();
        z.show(); //5.....4 因为用了super
    }
}

//this代表了一个本类对象的引用，super不代表父类的对象，而是代表一个父类的空间
//代码中从来没有创建过父类对象，子类为什么能获得父类的内容，只是因为子类持有super的引用
```

**结论**

1. this代表了一个本类对象的引用，super不代表父类的对象，而是代表一个父类的空间
2. 代码中从来没有创建过父类对象，子类为什么能获得父类的内容，只是因为子类持有super的引用

**以上结论的内存模型**：

![](images\继承成员变量内存关系.PNG)

> 上图作为了解，现实开发环境中，基本不会出现这种情况
>
> 例如上面的num其实只要在父类里定义就行，并且通常情况下都是私有的，通过set get方法就可以访问，没有必要重新定义。、

思考一个问题：父类中的私有内容，子类持不持有？？

确切的说，子类不能直接访问父类的私有内容，但是可以通过get，set间接访问

##### 1.3.2.3 成员函数的继承

```java
class Fu{
    void show1(){
        sop("fu show run");
    }
}

class Zi extends Fu{
    void show2(){
        sop("zi show run");
    }
}

class ExtendDemo2{
    main{
        Zi z = new Zi();
        z.show1(); 
        z.show2();
    }
}
```

内存示意：![](images\成员函数继承1.PNG)

```java
//子父都叫show方法
class Fu{
    void show(){
        sop("fu show run");
    }
}

class Zi extends Fu{
    void show(){
        sop("zi show run");
    }
}

class ExtendDemo2{
    main{
        Zi z = new Zi();
        z.show(); //zi show run	
    }
}
```

**结论：**

当子父类中出现成员函数一模一样的情况，会运行子类的函数，这种现象较作为覆盖操作，这是子父类中的特性。

函数的两个特性：

1. 重载，在一个类中。
2. 覆盖，在子类中，覆盖也称为重写，覆写，override。

**覆盖的注意事项：**

1. 子类方法覆盖父类方法时，子类权限必须要要大于等于父类的权限。

   ```java
   //错误例子
   class Fu{
       public void show(){
           sop("fu show run");
       }
   }
   
   class Zi extends Fu{
       void show(){ //不能覆盖 ，不信编译试试，编译不通过
           sop("zi show run");
       }
   }
   //--------------------------------------
   //下面这种情况不叫覆盖，覆盖只得是子类能调用的父类方法，private了子类根本访问不了，谈不上覆盖
   class Fu{
       private void show(){
           sop("fu show run");
       }
   }
   
   class Zi extends Fu{
       public void show(){ //不能覆盖 ，不信编译试试，编译不通过
           sop("zi show run");
       }
   }
   ```

2. 静态函数只能覆盖静态函数，或被静态函数覆盖

   ```java
   class Fu{
       private staic void show(){
           sop("fu show run");
       }
   }
   
   class Zi extends Fu{
       public void show(){ //不能覆盖 ，不信编译试试，编译不通过
           sop("zi show run");
       }
   }
   ```

**什么时候使用覆盖操作**

当对一个类进行子类的扩展时，子类需要报错父类的功能声明，但是要定义子类中该功能的特有内容是时，就是用覆盖才做完成。

```java
class Iphone{
    void call(){}
    void certification(){
        // password verify
    }
}
class IphoneX extends Iphone{
    void call(){}
    void certification(){
        // faceId verify
        //最后如果还要调用父类的方法
        super.certification();
    }
}
```

##### 1.3.2.4 构造函数的继承

```java
class Fu{
    Fu(){
        sop("fu run");
    }
}

class Zi{
    Zi(){
        sop("zi run");
    }
}

class ExtendsDemo4{
    main(){
       new Zi(); //1.Fu run  2.zi run 
    }
}
```

构造函数继承特点：

​	在子类构造对象时，发现	访问子类	构造函数时，父类也运行了。

why？

原因是：在子类的构造函数中第一行有一个默认的隐式语句：super();

> 注意，super（）调用的是空参构造函数

```java
class Fu{
    Fu(){
        sop("fu run");
    }
}

class Zi{
    Zi(){
        //super();//类似于this() //代表调用了父类的空参数构造函数
        sop("zi run");
    }
}

class ExtendsDemo4{
    main(){
       new Zi(); //1.Fu run  2.zi run 
    }
}
//--------------------------------------
//以下代码编译错误
class Fu{
    Fu(int x){
        sop("fu run");
    }
}

class Zi{
    Zi(){
        //super();父类没有空参构造函数
        // super(4);这样写没问题
        sop("zi run");
    }
}
```

**结论：**

子类的实例化过程中，子类中**所有的构造函数默认**都会访问父类中**空参数**的**构造函数**。

> 练习：以下代码打印什么？
>
> ![](images\构造继承练习.PNG)

##### 1.3.2.5 为什么子类的实例化的时候要访问父类的构造函数？

因为子类继承了父类，就要能访问父类中的部分成员，然后父类中的成员的初始化动作往往在构造函数中进行，因此，子类在执行自己的构造函数之前，先要执行父类的。

```java
class Fu{
    int num;
    Fu(){
        num = 10;
        sop("fu run");
    }
}

class Zi{
    Zi(){
        
        sop("zi run:"+num);//如果父类不执行构造，这的num=0，而构造了就等于10
    }
}
```

如果父类中没有定义父类的空参构造函数，那么子类的构造函数必须要用super明确调用父类哪个构造函数

同时子类构造函数中使用this调用了本类构造函数时，那么super()就没有了因为super和this都要定义在第一行，所以只能有一个，但是可以保证的是，子类中肯定会有其他额构造函数访问父类的构造函数。

> 注,super（）必须放在第一行，先执行父类构造函数，再执行子类

```java
public class ExtendsDemo {

    public static void main(String[] args) {
        
    }
}
class Fu{
    int num;
    Fu(){
        num = 10;
        System.out.println("fu run:"+num);
    }
    Fu(int num){
        this.num = num;
        System.out.println("fu run:"+num);

    }
}

class Zi extends Fu{
    Zi(){
        
        System.out.println("zi run:"+num);//如果父类不执行构造，这的num=0，而构造了就等于10
    }
    Zi(int num ){
        super(num);
        System.out.println("zi run:"+num);//如果父类不执行构造，这的num=0，而构造了就等于10
    }
}
```

> 构造函数的权限修饰符如果不写，那么就与类的修饰符一致
>
> ```java
> public class Foo // extends Object{
>     Foo(){ //与public Foo相同
>         super(); //即使没有显示继承，也有父类，上帝Object
>         return ;
>     }
> }
> ```

##### 1.3.2.6 对象实例化过程图解

思考：以下代码打印什么？

```java
public class ExtendsDemo5 {

    public static void main(String[] args) {
        Zi zi = new Zi();
        zi.show();
        
        //zi show:0
		//zi show:8
    }
}

class Fu{
    Fu(){
        //super();
        show();
    }
    void show(){
        sop("fu show");
    }
}

class Zi extends Fu{
    int num = 8 ;
    Zi(){
        super();
        //------->这里是分水岭，通过supoer初始化父类内容时，子类的成员变量并未显式初始化
        //等super（）父类完成后，才进行子类显式初始化
        System.out.println("constructor run :"+num);//打印8
        //打印8 因为父类先初始化，只有当父类初始化完毕才轮到子类的显式初始化，因此这时候8已经初始化了
    }
    void show(){
        sop("zi show:"+num);
    }
}
```

内存图解：（重点在构造器部分）

![](images\实例初始化过程.PNG)

**一个对象的实例化过程**：Person p = new Person();

1. Jvm读取指定路径下的Perosn.class文件，并加载进内存

   并会先加载Person的父类（如有有直接父类的情况下）

2. 在堆内存中开辟空间，分配地址。

3. 对对象中的成员变量进行默认初始化。

4. 调用对应的构造函数开始构造初始化。

5. 在构造函数中，会先调用父类的构造函数进行初始化。

6. 父类初始化完毕后，再对子类的成员变量进行显示初始化。

7. 再进行子类构造函数的特定初始化。

8. 初始化完毕后，将地址值赋给引用变量。（引用变量可不见得一定在栈内）

### 1.4 final关键字

1. final是一个修饰符，可以修饰类，方法，变量

2. final修饰的类不可以被继承

3. final被修饰的方法不能被修改

4. final修饰的变量是一个常量（注意这个常量和内存模型里的常量不是一回事），只能赋值一次。（开发最常用）

   为什么要用final修饰变量,在程序中如果一个数据是固定的，直接使用这个数据就可以了，但是阅读性差

5. 被final修饰的变量要起大写名字

   > 补充：常量池的概念https://blog.csdn.net/b1480521874/article/details/89506095
   >
   > https://blog.csdn.net/weixin_43194122/article/details/88894818
   >
   > 结论：final修饰符与常量池并没有直接联系
   >
   > 方法区：https://www.cnblogs.com/wangguoning/p/6109377.html

```java
//这个例子展示继承的坏处

class Fu{
    void method(){
        //调用底层的资源，这个方法不允许别修改
    }
}

class Zi{
    void method(){
           //只要一继承，就打破了父类的封装性
    }
}
//-----------------------------
//解决办法之一，final
//在类上加了final，class就不可以被继承
final class Fu{
    void method(){
        //调用底层的资源，这个方法不允许别修改
    }
}
//----------------------------------
//需求：一个类有多个方法，只有一个方法不能被修改
//在方法上加上final
class Fu{
    final void method(){ // 这样方法就不能被覆盖，编译错误
        //调用底层的资源，这个方法不允许别修改
    }
}
//---------------------------
// 局部变量用final修饰
//final修饰局部变量的场景，例如做十进制转换为二进制，模数2是固定的 final int modulus = 2；
class Fu{
    void method(){ 
       final int x = 9; //被final修饰的局部变量还存在栈中，叫不可变变量
       x= 9; //编译错误
       sop(x); 
    }
}
// 成员变量用final修饰
class Fu{
    final double PI = 3.14;//被final修饰的成员变量存在在方法区常量池中
    void method(){ 
       final int x = 9; //被final修饰的局部变量还存在栈中，叫不可变变量
       x= 9; //编译错误
       sop(x); 
    }
}
//---------------
//final修饰成员变量必须要手动初始化值。
class Fu{
    final double PI = 3.14;//被final修饰的成员变量存在在方法区常量池中
    final int x; //编译错误
    void method(){ 
       final int x = 9; //被final修饰的局部变量还存在栈中，叫不可变变量
       x= 9; //编译错误
       sop(x); 
    }
}
//---------------
//常量一般都加static，因为都常量了每个成员都一样，又不能改，就直接存静态区里了
class Fu{
    final double PI = 3.14;//被final修饰的成员变量存在在方法区常量池中
   	static final int x  = 7; 
    void method(){ 
       final int x = 9; //被final修饰的局部变量还存在栈中，叫不可变变量
       x= 9; //编译错误
       sop(x); 
    }
}
```

### 1.5 抽象类

抽象：笼统，模糊，看不懂，不具体。

```java
//用例：动物的吼叫功能

abstract class Animal(){//有抽象方法的类也必须加上abstract修饰符，代表抽象类
    abstract void roar();//动物的吼叫方式太多无法定义方法体，所以用抽象，
    
    void sleep(){
        .....  //抽象类可以有非抽象方法，比如大家共性的东西，那就可以定义方法体
    }
}

class Dog extends Animal(){
    void roar(){
        sop("汪汪")
    }
}

class wolf extends Animal(){
    void roar(){
        sop("嗷嗷")
    }
}
```

特点：

1. 方法只有声明没有实现时，该方法就是抽象方法，需要加关键字abstract；

2. 抽象方法必须在抽象类中，该类也被abstract修饰。

3. 抽象类不可以被实例化。因为调用抽象方法没有意义。

4. 抽象类必须有其子类覆盖所有抽象方法，否则这个子类不能被实例化，而且还是个抽象类:

   ```java
   abstract class Animal(){
       abstract void roar();，
       abstract void run();
   }
   //犬科类实现了一个抽象方法，但是没有全部实现，所以仍然是抽象类
   abstract class Canine  extends Animal{
       void run(){
           sop("run")
       }
   }
   ```

#### 1.5.1 抽象类的细节

1. 抽象类能有构造函数吗？

   有，用于给子类对象进行初始化

2. 抽象类可以不定义抽象方法吗？

   可以，但是很少见，目的就是不让该类创建对象。通常这个类的方法有方法体，但都是空。（这种方式已被jdk8接口替代）

3. 抽象关键字不可以和那些关键字共存？

   **private**：你都私有了，如何继承覆盖，编译都不通过

   **static**：你都静态了，就不需要对象了，对象也无法覆盖了

   **final**：加了final还怎么覆盖呢

4. 抽象类和一般类异同点？

   相同点：抽象类和一般类都是用来描述事物的，都在内部定义了成员

   不同点：

   - 一般类有足够的信息描述事物，抽象类描述事物的信息不足。
   - 一般类中不能定义抽象方法，而抽象类中可定义抽象方法。
   - 一般类可以被实例化，抽象类不可以被实例化。

5. 抽象类一定是个父类？

   是的，你不继承它，根本没法实例化它的对象，需要子类覆盖其方法后，才能使用方法。

#### 1.5.2 抽象练习

```java
/*雇员示例：
需求：程序员：姓名，工号，薪水，工作内容
	 经理：姓名，工号，薪水，工作内容 奖金，
对以上问题领域建立数据建模


分析：
在这个问题领域中，先找出涉及的对象
通过名词提炼法：
程序员：
	属性：姓名，工号，薪水，
	行为：工作
经理：
	属性：姓名，工号，薪水，奖金
	行为：工作
程序员和经理不存在直接继承关系（泛化关系），但可以进行抽取，因为都是公司的雇员
雇员和程序员和经理都存在直接继承关系

*/
// 描述雇员
class Employee{
    private String name; //顺便说下protected
    private String workNo;
    private double salary;
    Employee(){}
    Employee(String name,String workNo,String salary){
        
    }
    public abstract void work();
}
//描述程序员
class Programmer extends Employee{
    Programmer(String name,String workNo,String salary){
        super(name,workNo,salary);
    }
    
    public void work(){
        sop("code");
    }
}
class Manager extends Employee{
    private int bonus;
    Manager(String name,String workNo,String salary,int bonus){
        super(name,workNo,salary);
        this.bonus = bonus;
    }
    
    public void work(){
        sop("manage");
    }
}

```

### 1.6 接口

当一个类中的方法都是抽象方法可以用另一种形式定义表示：接口

> 接口和抽象类不是一回事，只是为了引入接口概念

```java
abstract class AbsDemo{
    abstract void show1();
    abstract void show2();
    
}
//接口定义的关键字是interface，但编译之后仍然class字节码文件
//接口常见的成员，而且这些成员都有固定的修饰服：
//1.全局常量：public static final
//2.抽象方法：public abstract
//由此得出结论：接口中的成员都是公用的
//接口总的修饰符可以不写，因为是固定的，编译器会帮你加上,但为了阅读性，最好还是加上
interface Demo{
    //public static final int NUM =4;
    //public abstract void show1();
    //public abstravct void show2();
    int NUM = 4;
    void show1();
    void show2();
}


```

#### 1.6.1 实现接口

接口里的方法都是抽象方法，所以都要实现

类与类之间是继承关系，类与接口之间是实现关系

```java
//接口不可以实例化，只能有实现了接口的子类，并覆盖所有抽象方法后，子类可以实例化，否则这个类就是抽象类
class DemoImpl implements Demo{
    public void show1(){}
    public void show2(){}
}

class InterfaceDemo(){
    main(){
        DemoImpl d =new DempImpl();
        sop(d.NUM);
        sop(DemoImpl.NUM);
        sop(Demo.NUM);
        //d.NUM =4;编译错误
    }
}
```

#### 1.6.2 接口的多实现

类的继承只能是单一继承，java不直接支持多继承，会存在调动的不确定性。

java对多继承的改良就是接口的多实现。

一个类可以实现多个接口。很多语言有类似的特性，如golang

```java
//多实现的好处
//一个程序员既是动物，又是雇员，但是动物和雇员并不村在直接关系，
//这时候将雇员和动物抽象成接口，让程序员取实现
interface Employee{
    void work();
}
interface Animal{
    void roar();
}

class Programmer implements Animal,Employee{
    public void work(){
        sop("coding");
    }
    pubic void roar(){
        sop("累死了");
    }
}

class InterfaceDemo{
    main(){
       Programmer p  = new Programmer();
       p.work();
       p.roar(); 
    }
}

//---------------------------------
//对于不确定性的好处
interface A{
    void work();
}
interface B{
    void work();
}
class C implements A,B{
     void work(){} //这个实现方法同时覆盖了两个接口
}
class InterfaceDemo{
    main(){
       C c = new C();
       c.show();//不会存在不确定性 
    }
}
// 以上代码最好不要出现，这没什么意义，每个接口都应该有自己的描述事物

```

#### 1.6.3 类的继承与实现

##### 一个类在继承另一个类的同时还能实现多个接口

接口的出现避免了单继承的局限性

```java
//程序员还可以有个爹:农民
interface Employee{
    void work();
}
interface Animal{
    void roar();
}

class Farmer {
    void farm(){};
}

class Programmer extends Farmer implements Animal,Employee{
    public void work(){
        sop("coding");
    }
    pubic void roar(){
        sop("累死了");
    }
    public void farm(){
        sop("脸朝屏幕背朝门，辛勤劳作背锅人");
    }
}

class InterfaceDemo{
    main(){
       Programmer p  = new Programmer();
       p.work();
       p.roar(); 
    }
}
```

##### 接口与接口之间关系

可以是继承关系，而且接口可以多继承

原因是接口没方法体

```java
interface A{
    void work();
}
interface B{
    void work();    
}
interface C extends A,B{
    void work();    
}

class D implements C{

    @Override
    public void work() {

    }

}
```

#### 1.6.4 接口的特点

1. 接口是对外暴露的规则
2. 接口是程序的功能扩展
3. 接口的出现降低耦合度
4. 接口可以用来多实现

```java
//例子：笔记本电脑
//笔记本的触摸板不爽，要用鼠标，所以留了usb接口：
// 暴露了usb接口规则，只能用usb
// 有了usb口，降低了鼠标和笔记本的耦合度，鼠标不用就拔掉
// 凡是usb口的东西都能差，提高了笔记本的功能扩展性，
// 不同的设备接入usb，当然是多实现
```

接口在生活中无处不在。在java开发中，接口设计的好，代码不仅提高的是复用性，最重要的是便于代码的迭代。

例如：定义获取数据存取接口，当有一天代码并发量高了，可以重新对该接口的实现进行重构，而不需要重新定义接口

#### 1.6.5 接口与抽象类的去区别

相同点：都是不断向上抽取而来。

不同点：

1. 抽象类需要被继承，而且是单继承，接口需要被实现，可以被多实现

2. 抽象类中可以定义抽象方法和非抽象方法，接口中只能定义抽象方法，需要子类实现（jdk8后不成立）

3. 抽象类的继承是 is a关系：在定义该体系的基本共性内容

   接口的实现往往是 has 关系：在定义体系的额外功能

   > 学生基本功能是学习，学生抽烟是额外功能，老师也有可能有额外功能，
   >
   > 犬按功能分：搜救犬，导盲犬

#### 1.6.6 接口的应用

```java
//已usb作为例子
interface Usb{
    void open();
    void close();
}
class Upan implements Usb(){
    public void open(){
        sop("Upan close");
    }
    public void open(){
        sop("Upan close");
    }
}
class Mouse implements Usb(){
    public void open(){
        sop("Mouse close");
    }
    public void open(){
        sop("Mouse close");
    }
}

class Laptop{
	public void useUsb(Usb usb){ //这个地方就是多态
		usb.open();
        usb.close();
	}
}

class IntefaceDemo1{
    public void main(String[] args){
        Laptop  laptop=  new Laptop();
        laptop.useUsb(new Upan());
        laptop.useUsb(new Mouse());
    }
}
```

#### 1.6.7 JDK8颠覆了接口

```java
public interface MyInter {
    public static final int age = 20;
    public abstract void show();
    int getInt();
    default String getString(){
        return "Default String";
    }
}

```

**默认方法的优势**：

- 提供一种拓展接口的方法，而不破坏现有代码。

- 在JDK8以前，如果为一个使用的接口增加一个新方法，必须在所有实现类中添加该方法的实现。

- JDK8以后的默认方法则解决了这个问题，它提供了一个实现，当没有显示提供其他实现时就采用这个实现。这样新添加的方法将不会破坏现有代码。

- 默认方法是可选的，子类可以根据不同的需求Override默认实现。

JDK8之所以这么做，其实和以上关系不大，而是因为为了引入函数式编程的语法糖。