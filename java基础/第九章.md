# 第九章 工具类

## 1.Object 类

Object是所有类的根类。

### 1.1 equals方法

[^]: 查看java8 Object api

```java
/**
 * ObjectDemo
 */
public class ObjectDemo {

    public static void main(String[] args) {
        Person p1 = new Person(11);
        Person p2 = new Person(11);
        System.out.println(p1==p2); //这比的啥？地址值
        System.out.println(p1.equals(p2)); //这比的啥？地址值
        Person p3 = p1;
        System.out.println(p3==p1); //说明object的equals方法比较的是==
    }
}


class Person{
    private int age;
    Person(int age){
        this.age =  age;
    }
}
```

结论:子类不覆盖equals方法的话，默认调用Object的equals方法，那么比较的是地址值

> 例子，让equals比较人的年龄
>
> ```java
> public class ObjectDemo {
> 
>     public static void main(String[] args) {
>         Person p1 = new Person(11);
>         Person p2 = new Person(11);
>   
>     }
> }
> 
> 
> class Person{
>     private int age;
>     Person(int age){
>         this.age =  age;
>     }
>     //
>     public boolean equals(Object o){
>         return this.age==(Person)o.age; //编译失败，Object没有age属性
>     }
> }
> //-----------写成如下
> class Person{
>     private int age;
>     Person(int age){
>         this.age =  age;
>     }
>     public boolean equals(Object o){
>         if(o instanceof Person){
>             Person p1 = (Person)o;
>             return this.age==p1.age;
>         }
>         return false;
>     }
> }
> 
> // 也可以抛类型转换异常
> 
> class Person{
>     private int age;
>     Person(int age){
>         this.age =  age;
>     }
>     //
>     public boolean equals(Object o){
>         if(o instanceof Person){
>             Person p1 = (Person)o;
>             return this.age==p1.age;
>         }
>         throw new ClassCastException("类型转换异常");
>     }
> }
> ```

结论：一般都会覆盖此方法，根据对象特有的内容，建立判断对象是否相同的依据。

### 1.2 hashCode 方法

[^]: 查看java8 Object api

```java
/**
 * ObjectDemo
 */
public class ObjectDemo {

    public static void main(String[] args) {
        Person p1 = new Person(11);
        Person p2 = new Person(11);
        System.out.println(p1);
        System.out.println(p1.hashCode()); 
        System.out.println(Integer.toHexString(p1.hashCode()); //打印十六进制hashcode
        
    }
}


class Person{
    private int age;
    Person(int age){
        this.age =  age;
    }
    //
    public boolean equals(Object o){
        if(o instanceof Person){
            Person p1 = (Person)o;
            return this.age==p1.age;
        }
        throw new ClassCastException("类型转换异常");
    }
    
	//比较覆盖前和覆盖后打印值得不同
    // public int hashCode(){
    //     return age;
    // }
}
```

> java8 api中说的很清楚，Ojbect的hashcode方法返回的是内部地址值转换为一个integer
>
> This is typically implemented by converting the internal
>
> ​     \* address of the object into an integer

### 1.3 getClass方法

要理解class对象，就要理解对于java而言，字节码文件也是对象

class类的对象你是不可能new的，因为没有`Class` has no public constructor

只能由jvm虚拟机进行对象创建，具体是经由类加载器调用`defineClass` 方法进行创建。

![](images/说明class类型.PNG)

> 拿到class对象后，当然能获得他的属性和调用它的行为
>
> 他能获得字段信息，方法信息，继承信息，甚至能调用方法，创建对象。

#### class字节码对象也存在堆内存中。

![](images/字节码文件内存位置.PNG)

```java
//举例说明
Person p1 = new Person(11);
Person p2 = new Person(11);
System.out.println(p1.getClass()==p2.getClass()); //true
```

结论：class类可以干的事很多，用来反射最主要，编写框架是经常性用到，这就是java的动态性。

### 1.4 toString方法

。。。。不说了。随便举例子

## 2. 包概念

1. 对类文件进行分类管理
2. 给类提供多层命名空间（命名空间就是为了避免重复，前缀名用来区分类）。
3. 写在源码的第一行。
4. 类名的全称是包名.类名。
5. 包也是一种封装形式。

> 包的基本作用举例子
>
> 在一个文件夹下，两个java文件，其中每个java文件都有Person类，两个任意编译一个
>
> 就会覆盖另一个的Person.class字节码文件，所以需要有包的概念来解决这事。	

##### 包名书写规范：必须小写

```java
package mypack;

public class PackageDemo{
    
}
```



自动创建包的编译模式命令

```bash
javac -d . PackageDemo.java
javac -d ./output  -encoding utf-8 .\DemoB.java
```

以上命令自动在文件系统中创建文件夹

一下命令运行文件

```bash
java mypack.PakageDemo
```



### 2.1 包与包之间访问

> 注： 编译器理论上在编译时，可以自动寻找依赖的java源文件，而不需要一个个的手动编译，但是前提是这些文件的位置要符合包的声明位置，否则只能将源文件先进行编译

结论：包与包之间进行类的访问，被访问的包中的类要是public，这个类中被访问的方法也必须是public

​	

##### import用来简化全限定名的编写

通配符*的使用：

最关键的是*能配这个包里的类，不能导入包里的包，说白了只找本层目录

```java
import abc.*;
import abc.cde.*;
```

### 2.2 jar

java的压缩包：将多个文件合并成一个文件

打可执行jar包

```
jar -cef test.CardLayoutDemo CardLayoutDemo.jar test

以上命令及参数的含义如下：

jar命令为java自带的专用打包工具；

c代表生成新的jar包；

e代表可执行的类，亦即main方法所在的类。书写时要加上包名，在本例中是后面的test.CardLayoutDemo；

f代表生成的jar包的名称，在本例中是CardLayoutDemo.jar。此包名可以随意命名，没有规定；

test最后面的这个参数表示将test目录下的所有文件都打包放到新的jar包中。

```

