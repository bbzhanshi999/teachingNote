# 第十一章 并发编程

## 并发与并行

很多人都对其中的一些概念不够明确，如同步、并发等等，让我们先建立一个数据字典，以免产生误会。

- 多线程：指的是这个程序（一个进程）运行时产生了不止一个线程
- 并行与并发：
  - 并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。
  - 并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈。

![](images/并发与并行.PNG)

> java的多线程实际上在多核cpu的情况下是在并发与并行之间进行切换。



## 进程与线程

进程与线程都和并行和并发有关系，都是对计算机资源的一种划分单位，但是区别是：

- 进程所划分的内存空间在进程之间是不可共享的，例如qq的内存空间不可能给java虚拟机访问

  j进程是操作系统进行资源分配和调度的一个独立单位

- 线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。

  一个进程可以存在多个线程，各个线程之间可以共享程序的内存空间，当然就可以共享一些数据。

- 进程之间的切换开销较大，因为内存和硬盘根本无法跟得上cpu指针的切换速度，所以导致了进程间的切换极为缓慢，那么这样就失去了切换的意义，不如串行执行。

![](images/进程线程内存关系.png)



## 线程的生命周期

### 对象生命周期：

在程序开发中，将一个对象从实例化完成，到这个对象使用结束并销毁。

### 线程生命周期：

一个线程被实例化完成，到这个线程销毁，中间的过程。

### 线程的状态：

#### 1.新生态：New

一个线程对象的实例化完成，但是没有做任何的操作。

#### 2.就绪态：Runnable

一个线程已经被开启，已经开始争抢cpu时间片。

#### 3.运行态：Running

一个线程抢到了CPU时间片，开始执行这个线程中的逻辑代码。

#### 4.阻塞态：Blocked

一个线程在运行过程中，受到某些操作的影响，放弃了已经获取到的CPU时间片，并且不再参与CPU时间片的

争夺，此时线程处于挂起状态。

#### 5.死亡态: Dead

一个线程对象需要被销毁

![](images/线程状态切换.PNG)

![](images/线程的状态.png)

## 线程的开辟方式

### 1.继承Thread类

```java
package com.neuedu;

public class ThreadDemo1 {
	
	public static void main(String[] args) {
		//创建线程对象，使得线程完成New状态
		MyThread myThread = new MyThread();
		//调用start方法，线程进入Runnable状态
		myThread.start();
		
		System.out.println("主线程执行完毕");
		
	}
}

class MyThread extends Thread{

	@Override
	public void run() {
		for(int x= 0;x<10;x++) {
			System.out.println(Thread.currentThread()+":"+x);
		}
	}
	
	
}
```

### 2.实现Runnable接口

```java
package com.neuedu;

public class ThreadDemo1 {
	
	public static void main(String[] args) {
		
		//创建runnable接口实例
		Runnable runable = ()->{
			for(int x= 0;x<10;x++) {
				System.out.println(Thread.currentThread().getName()+":"+x);
			}
		};
		
		//创建线程 New
		Thread thread = new Thread(runable);
		
		//启动线程 Runnable
		thread.start();
		
		System.out.println("主线程执行完毕");
		
	}
}
```

### 二者的优劣：

​	显然第二种更加灵活，因为java可以多实现，但不能多继承

## 线程常用方法

### 1.线程命名

```java
Thread thread = new Thread(runable,"custom");
thread.setName("custom");
```

### 2.线程的休眠

调用Thread静态方法sleep进行线程休眠，`sleep(long millisecond)`接收一个毫秒值，并且需要捕获异常`InterruptedException`异常

> 当线程sleep之时，就会放弃线程的cpu时间片使用权，线程进入到阻塞状态

```java
public class ThreadDemo1 {
	
	public static void main(String[] args) {
		
		//创建runnable接口实例
		Runnable runable = ()->{
			for(int x= 0;x<10;x++) {
				try {
					Thread.sleep(1000);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				System.out.println(Thread.currentThread().getName()+":"+x);
			}
		};
	
		Thread thread = new Thread(runable,"custom");
		
		thread.start();
		
		System.out.println("主线程执行完毕");
		
	}
}
```

### 3.线程的优先级

> 设置线程的优先级，只是修改这个线程抢到cpu时间片的概率
>
> 并不是优先级高的线程一定能抢到时间片

优先级的设置是0-10的整数，默认是5

> 由于两个线程都是Runnable状态，假定在单核cpu的情况下，二者是必须要争抢cpu时间片的，那么此时二者就是在执行态和就绪态之间来回切换。

```java
public class ThreadDemo1 {
	
	public static void main(String[] args) {
		
		setPriority();
	}
	
	
	public static void setPriority() {
		Runnable r = ()->{
			for(int x= 0;x<100;x++) {
				System.out.println(Thread.currentThread().getName()+":"+x);
			}
		};
		
		Thread t1 = new Thread(r,"thread1");
		Thread t2 = new Thread(r,"thread2");
		t1.setPriority(1);
		t2.setPriority(10);
		t1.start();
		t2.start();
	}
}
```

### 4.线程的礼让

线程礼让：指的是当前线程在Running状态下释放自己的cpu资源，由运行状态，回到就绪状态

```java
public static void main(String[] args) {

    threadYield();
}


public static void threadYield() {
    Runnable r1 = ()->{
        for(int x= 0;x<10;x++) {
            System.out.println(Thread.currentThread().getName()+":"+x);
        }
    };
    Runnable r2 = ()->{
        Thread.yield(); //释放执行权
        for(int x= 0;x<10;x++) {
            System.out.println(Thread.currentThread().getName()+":"+x);
        }
    };
    new Thread(r2,"礼让线程").start();
    new Thread(r1,"普通线程").start();
}
```

> 注意：在cpu性能非常强的状态下，礼让线程有可能先执行完，这很正常，多核cpu根本不需要礼让，cpu忙的过来。

## 临界资源问题

临界资源问题就是线程安全问题

> 思考以下用例：
>
> 四个售票员在同时售票，而票是有限的。

```java
public class TicketSale {
	int num = 10;
	
	
	public static void main(String[] args) {
		TicketSale ticketSale = new TicketSale();
		//模拟四个售票员同时卖票
		Runnable r= ()->{
			while(ticketSale.num>0) {
				System.out.println(Thread.currentThread().getName()+":卖出1张，剩余:"+--ticketSale.num);
			}
			
		};
		
		new Thread(r,"赵丽华").start();
		new Thread(r,"陈秀莲").start();
		new Thread(r,"王美丽").start();
		new Thread(r,"李淑芬").start();
	}
}
```

> 以上代码执行时，会发现当多个线程在操作一个成员变量时，就会发生执行结果错误，因为代码在执行过程中，可能会从Running状态切换回Runnable状态，而这时候已经--的计算已经完成了

### 问题产生的原因

以上代码中线程在运行态和就绪态之间来回切换，由于打印的那句语句非原子性，所以当取到ticket值时，并没有执行打印，所以大数字会打在小数字后面

## 锁

通过锁将临界资源锁住，使得线程想要操作资源必须获得锁。

### `synchronized`关键字

synchronized关键字持有的锁是互斥锁,synchronized加锁的方法就是一个原子操作

```java
	TicketSale ticketSale = new TicketSale();
		//模拟四个售票员同时卖票
		Runnable r= ()->{
            synchronized(lock){
                	while(ticketSale.num>0) {
				System.out.println(Thread.currentThread().getName()+":卖出1张，剩余:"+--ticketSale.num);
			}
            }
		
			
		};
		
		new Thread(r,"赵丽华").start();
		new Thread(r,"陈秀莲").start();
		new Thread(r,"王美丽").start();
		new Thread(r,"李淑芬").start();
```

此时只有一个线程获得了同步锁标记，并且处于running状态执行代码，而其他线程都进入到了阻塞态，在锁池中进行等待，但同步锁被释放后，这些线程将争抢这把锁，先抢到的就会从blocked状态回到runnable状态，争抢到cpu时间片后，进入运行态，当代码执行完毕后，释放锁。

### 加锁的方式

```java
private int count = 10;
private Object  o =new Object();
public void m(){
    
    //这里o的对象就是锁，注意o指向的堆内存对象中会记录这一点，而不是引用
    synchronized(o){
        count++;
        sop(Thread.currentThread().getName()+"count="+count);
    }
}

//--------------------------------------------
//用this作为锁对象，注意，锁的是对象，不是代码，就好比代码是厕所，要想用厕所并且不受干扰，你要拿着锁也就
//是对象把门锁了
private int count = 10;
public void m(){
    
    //如果单独创建一个对象当做锁的话，实在是浪费资源，而this指向的也是对象，所以正好用上
    synchronized(this){
        count++;
        sop(Thread.currentThread().getName()+"count="+count);
    }
}
//-----------------------------------------------
//直接声明在方法上的锁，等同于将对象作为锁
private int count = 10;

public synchronized /*这里等同于锁定this对象*/ void m(){
    count++;
    sop(Thread.currentThread().getName()+"count="+count);
}

//-----------------------------------------------
public synchronized /*这里等同于锁定Class对象*/ static void m(){
    count++;
    sop(Thread.currentThread().getName()+"count="+count);
} 	
//上面代码相当于如下
public static void mm(){
    synchronized(T.class){
        count++;
    }
}

```

### ReentrantLock显式锁

```java
public static void main(String[] args) {
		TicketSale ticketSale = new TicketSale();
		// 模拟四个售票员同时卖票

		ReentrantLock lock = new ReentrantLock();

		Runnable r = () -> {
			lock.lock();
			while (ticketSale.num > 0) {
				System.out.println(Thread.currentThread().getName() + ":卖出1张，剩余:" + --ticketSale.num);
			}
			lock.unlock();
		};

		new Thread(r, "thread-1").start();
		new Thread(r, "thread-2").start();
		new Thread(r, "thread-3").start();
		new Thread(r, "thread-4").start();
	}
```

### 死锁

多个线程彼此持有对方所需要的锁对象，而不释放自己的锁：

A线程持有a锁，等待b锁;B线程持有b锁，等待a锁

```java
package com.neuedu;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class DeadLock {

	public static void main(String[] args) {
		String a ="A";
		String b = "B";
		
		Runnable r1 = ()->{
			synchronized (a) {
				System.out.println(Thread.currentThread().getName()+"：持有锁a，等待锁b");
				synchronized (b) {
					System.out.println(Thread.currentThread().getName()+"同时持有ab锁");
				}
			}
		};
		Runnable r2 = ()->{
			synchronized (b) {
				System.out.println(Thread.currentThread().getName()+"：持有锁b，等待锁a");
				synchronized (a) {
					System.out.println(Thread.currentThread().getName()+"同时持有ab锁");
				}
			}
		};
		
		new Thread(r1,"thread-A").start();
		new Thread(r2,"thread-B").start();
	}
}

```

> 程序开发中的死锁现象更为负载，有可能是循环死锁

## 等待唤醒机制

### `wait()`方法：

等待，是Object类中的一个方法，当前的线程释放自己的锁标记，并且让出cpu资源。使得当前线程进入等待队列（等待Block）。

### `notify()`方法：

通知,是object类中的方法，唤醒等待队列中的一个线程，使这个线程进入到锁池。

### `notifyAll()`方法:

唤醒等待队列中的的所有线程，并使这些线程进入锁池。

```java
package com.neuedu;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class DeadLock {
	
	
	
	
	public static void main(String[] args) {
		String a ="A";
		String b = "B";
		
		Runnable r1 = ()->{
			synchronized (a) {
				System.out.println(Thread.currentThread().getName()+"：持有锁a，等待锁b");
				
				try {
					a.wait();
				} catch (InterruptedException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				synchronized (b) {
					System.out.println(Thread.currentThread().getName()+"同时持有ab锁");
				}
			}
		};
		Runnable r2 = ()->{
			synchronized (b) {
				System.out.println(Thread.currentThread().getName()+"：持有锁b，等待锁a");
				synchronized (a) {
					System.out.println(Thread.currentThread().getName()+"同时持有ab锁");
					a.notify();
				}
			}
		};
		
		new Thread(r1,"thread-A").start();
		new Thread(r2,"thread-B").start();
	}
}
package com.neuedu;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class DeadLock {
	
	
	
	
	public static void main(String[] args) {
		String a ="A";
		String b = "B";
		
		Runnable r1 = ()->{
			synchronized (a) {
				System.out.println(Thread.currentThread().getName()+"：持有锁a，等待锁b");
				
				try {
					a.wait();
				} catch (InterruptedException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				synchronized (b) {
					System.out.println(Thread.currentThread().getName()+"同时持有ab锁");
				}
			}
		};
		Runnable r2 = ()->{
			synchronized (b) {
				System.out.println(Thread.currentThread().getName()+"：持有锁b，等待锁a");
				synchronized (a) {
					System.out.println(Thread.currentThread().getName()+"同时持有ab锁");
					a.notify();
				}
			}
		};
		
		new Thread(r1,"thread-A").start();
		new Thread(r2,"thread-B").start();
	}
}
//-------------------------------------
//三个线程同时竞争锁，notifyAll

package com.neuedu;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class DeadLock {
	
	
	
	
	public static void main(String[] args) {
		String a ="A";
		String b = "B";
		
		Runnable r1 = ()->{
			synchronized (a) {
				System.out.println(Thread.currentThread().getName()+"：持有锁a，等待锁b");
				
				try {
					a.wait();
				} catch (InterruptedException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				synchronized (b) {
					System.out.println(Thread.currentThread().getName()+"同时持有ab锁");
				}
				a.notifyAll();
			}
		};
		Runnable r2 = ()->{
			synchronized (b) {
				System.out.println(Thread.currentThread().getName()+"：持有锁b，等待锁a");
				synchronized (a) {
					System.out.println(Thread.currentThread().getName()+"同时持有ab锁");
					a.notifyAll();
				}
			}
		};
		
		new Thread(r1,"thread-A").start();
		new Thread(r1,"thread-C").start();
		new Thread(r2,"thread-B").start();
	}
}

```

## 多线程下的单例设计模式

```java
class Boss{
    private Boss(){}
    
    private Boss boss=null;
    
    public static getInstance(){
        synchronized(""){
            if(boss!=null){
                boss = new Boss();
            }
        }
    }
}
```

## 生产者消费者设计模式

### 生产者：

作用是生产产品。

生产逻辑：通过一个生产标记，判断是否需要生产产品。

如果需要生产：生产产品,并通知消费者消费。

如果不需要生产，等待。

### 消费者:

作用是消费产品。

消费逻辑：判断是否有足够的产品可供消费。

如果可以消费，获取产品，进行消费。

如果不可以消费，等待。

> 分析：
>
> 把生产者当成厨师，消费者当成食客，那么消费者和生产者都将对临界资源食品进行操作，那么我们要对临界资源进行访问控制。

### 代码实现

```java
// 商品
package com.neuedu.pc;

public class Product {
	
	private String name;

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public Product(String name) {
		super();
		this.name = name;
	}

	@Override
	public String toString() {
		return "Product [name=" + name + "]";
	}
	
}
//-----------------------------------------
//商品池
package com.neuedu.pc;

import java.util.LinkedList;

public class ProductPool {

	private LinkedList<Product> list;
	private int size;
	
	
	public ProductPool( int size) {
		this.list = new LinkedList<>();
		this.size = size;
	}
	
	public synchronized void push(Product product) {
		if(list.size()>=size) {
			try {
				this.wait(); //如果商品已经做够，就不生产了，释放掉锁标记，让消费者区竞争锁消费
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		this.list.addLast(product);
		System.out.println("商品池中增加一件商品，剩余商品："+this.list.size());
		//唤醒其他的生产者和消费者，
		this.notifyAll();
	}

	public  synchronized Product pop() {
		if(list.size()<1) {
			try {
				this.wait();
				//如果商品都没了，就释放当前锁标记，让生产者从锁池中竞争获取锁，
				//然后回到就绪状态竞争cpu时间片生产商品。
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		
		Product product = this.list.removeFirst();
		System.out.println("商品池中消费一件商品，剩余商品："+this.list.size());
		//唤醒其他的消费者进入到锁池，竞争获取锁继续消费
		this.notifyAll();
		return product;
	}
}
//-----------------------------------------
// 生产者
package com.neuedu.pc;

public class Producer implements Runnable {

	private ProductPool pool;
	
	public Producer(ProductPool pool) {
		this.pool = pool;
	}
	
	@Override
	public void run() {
		int count = 0;
		while(true) {
			pool.push(new Product("面包"));
		}
		
	}
}
//---------------------------------------
//消费者
package com.neuedu.pc;

public class Consumer implements Runnable {

private ProductPool pool;
	
	public Consumer(ProductPool pool) {
		this.pool = pool;
	}
	
	@Override
	public void run() {
		int count = 0;
		while(true) {
			Product pop = pool.pop();
		}
	}
}
//------------------------------------
//程序主函数
package com.neuedu.pc;

public class Program {
	
	public static void main(String[] args) {
		ProductPool pool = new ProductPool(20);
		
		new Thread(new Producer(pool),"生产者1").start();
		new Thread(new Consumer(pool),"消费者1").start();
	}
}
```

以上的代码实现存在缺陷，假如有多个生产者和消费者，那么会同时唤醒消费者和生产者因为nofityAll方法会把所以等待这把锁的线程同时唤醒。

### Lock与Conditon配合多监视器实现

lock接口的好处是可以在进行通知唤醒和等待的时候用过一把锁中的多个监视器来分别控制生产者和消费者的等待与唤醒

```java
//修改产品池

package com.neuedu.pc;

import java.util.LinkedList;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class ProductPool {

	private LinkedList<Product> list;
	private int size;

	private Lock lock = new ReentrantLock();
	private Condition prodCond = lock.newCondition();
	private Condition consCond = lock.newCondition();

	public ProductPool(int size) {
		this.list = new LinkedList<>();
		this.size = size;
	}

	public void push(Product product) {
		lock.lock();

		try {
			if (list.size() >= size) {
				//如果商品满了，就唤醒消费者，而生产者释放锁进入等待阻塞区
				consCond.signal();
				prodCond.await();
			}
			this.list.addLast(product);
			System.out.println("商品池中增加一件商品，剩余商品：" + this.list.size());
			
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} finally {
			lock.unlock();
		}

	}

	public Product pop() {
		lock.lock();
		Product product=null;
		try {
			if (list.size() < 1) {
				//如果商品没了，就通知生产者进行生产，消费者放弃锁
				prodCond.signal();
				consCond.await();
			}
			product = this.list.removeFirst();
			System.out.println("商品池中消费一件商品，剩余商品：" + this.list.size());
			return product;
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} finally {
			lock.unlock();
		}
		return null;
	}

}

```

